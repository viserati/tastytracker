ASYNCHRONOUS SERVICES

Although it wasn't within the scope of this book to set up an actual
web-based data service, many web applications use them. Most data for
web applications is kept in a database of some sort, and direct access
to the database is something that's often not possible, or is
undesirable for security reasons. Many data providers prefer instead
to offer an API, a more easily controlled means of accessing the
data. Your app talks to the API, and the API talks to the database.

APIs vary widely, but in general they follow the CRUD model: there
will be some sort of method to create a new data record, one or more
methods of retrieving data, a method for updating an existing record,
and a method for deleting a record. Most web-based APIs these days are
variations on what's called the REST approach (you'll see things
described as a "REST API" or a "RESTful API"), which without going
into the fifty-page explanation, means that:

-- HTTP is used as the transmission method (the way you send and
   receive information). Every request to send or obtain data is an
   HTTP request.

-- The four types of HTTP requests (GET, POST, PUT, and DELETE) are
   used for retrieve, create, update, and delete actions,
   respectively. Sometimes these are the only way of distinguishing
   the actions--we've worked with REST APIs where the only difference
   between "retrieve a meal record" and "delete a meal record" was
   whether it was a GET or DELETE request, all other parameters being
   identical.

If we were adapting our code to talk to a remote API, we'd first
determine (based on the API's documentation) whether the API was doing
some of the work we currently do ourselves. Our getList() function in
meal.service.ts takes many parameters and returns only results which
match those parameters. Ideally we'd like to pass those parameters to
a remote getList() or equivalent, have it do the filtering work, and
return only matching results to us--but sometimes, APIs are very
crude. They may only have a get() function or equivalent that returns
all meals, in which case we'd still have to do all the iterating and
sifting.

The other adaptation we'd have to make is that HTTP requests are
asynchronous. They take their own time to complete, you don't know how
long they'll take to finish (or whether they will!), and you probably
don't want to make your code wait, doing nothing and confusing the
user, while the remote API call does its thing. Imagine your app
waiting on a response from a remote service, while from the user's
perspective, the page in the browser hasn't even begun to draw
yet. Your poor user is left stuck staring at a "Loading" message,
wondering what went wrong. In the worst case, the response takes so
long that the user's web browser eventually times out (stops waiting
for a response) and shows the user an error.

Angular handles this problem by using an approach from ES6 JavaScript
called a Promise. A Promise is just that; it's a promise that "there
will eventually be some kind of result here" (though that result could
be an error). Your code can proceed without waiting for the Promise to
be fulfilled; only the parts which absolutely depend on having data in
that Promise have to wait for it.

Fetching the meal list with GET

A full discussion of how to work with Promises is beyond this brief
overview, though we've provided links to more information at the end
of this document. But in terms of real code, let's imagine that
meal.service.ts was trying to talk to a REST API instead of local
storage. Start with the getList() function. Suppose we've looked at
the documentation for this imaginary API and found that it accepts a
GET request formed by using this base URL:
     http://some.web.domain/api/meal
plus none, either, or both of these two parameters (substitute real
values for the parts in square brackets):
     id=[restaurant number]
     type=[meal type code]

We're going to use just these two parameters in the interest of
keeping this example simple, and we've removed the other parameters
from this version of getList().

Parameters in a GET request are separated from the base URL by a
question mark and from each other by ampersands. So if we wanted to
query for all breakfasts from the restaurant with an ID of 5, we'd
send this GET request:
     http://some.web.domain/api/meal?id=5&type=B

The first job of our new getList() is to assemble that URL from the
parameters given. It would probably make sense to store the base URL,
which is the same for all meal requests, in a component-level
variable. Assume this.baseUrl contains that information.

We'd write getList() something like this:

getList(restaurant: number, mealtype: string): Promise<Meal[]> {
   let requestURL: string = this.baseUrl;
   let params: Array<string> = [];

   if (!restaurant === 0) {
      params.push('id='+restaurant.toString());
   }
   if (!mealtype === '') { 
      params.push('type='+mealtype);
   }
   if (params) {
      requestUrl = requestUrl + '?' + params.join('&');
   }

   return this.http.get(requestURL)
      .toPromise()
      .then(response => response.json().data as Meal[])
      .catch(this.handleError);
}

Although we're missing a few necessary things for it to work, which we
discuss in a moment, what this code says is that we form an HTTP GET
request of our URL, and the result we (eventually) get back when we
send that request has the following methods applied to it:

-- We want the response as a Promise (the .toPromise()
   method). Angular's HTTP methods return responses as Observables,
   another approach to asynchronous transactions which is more
   flexible than Promises but also more difficult to work with. Since
   we're only scratching the surface, we won't go there.

-- When it returns (the .then method), we're expecting to get back
   JSON-style data which we then translate into an array of Meal. We
   could be getting back responses in some format other than JSON, and
   we'd adjust the parameters to this method accordingly, but most
   REST APIs return either JSON or XML.

-- If it gets an error (the .catch method), we use this.handleError()
   to deal with telling the user what happened.

Before we proceed with the implications of returning a Promise instead
of actual data, a few things need to happen in the meal service
component and in the app module.

First and foremost, Angular knows how to make HTTP requests, but we
haven't imported the parts of Angular that do so--we didn't need them
before. We'd need to add an import line to meal.service.ts:
    import { Headers, Http } from '@angular/http';
We don't need Headers yet, but we will in just a moment. You'll see why.

We'd also have to make app.module.ts aware of our new requirement:
     import { HttpModule } from '@angular/http';
and HttpModule would need to be added to the imports section of the
@NgModule() parameters. You would also have to add a map line to
systemjs.config.js so that the path @angular/http was meaningful.

Back in meal.service.ts, at the end of the import statements, we'd
need one more:
     import 'rxjs/add/operator/toPromise';
Angular doesn't have a toPromise handler of its own, and doesn't
automatically import the RxJS version because you may want to provide
your own way of doing things.

[Note that our distribution file set would change; we'd be adding a
new Angular dependency and a new RxJS dependency. Sometimes keeping
track of what new dependencies a change introduces is a harder job
than making the change itself.]

We'd also need a handleError() in the component. Here's a minimalist
one:

handleError(error: any): Promise<any> {
   console.error('An error occurred', error);
   return Promise.reject(error.message || error);
}

It sends whatever error occurred to the web console, and passes back
the error to whatever code was asking for the Promise in the first
place. We'll come to that.

Creating a meal with POST

POST URLs aren't made like GET URLs. GET requests combine all the
parameters right in the URL. POSTs, which tend to have a lot more data
to send, use only the base URL and then send the parameters in the
body of the HTTP request. This means we'd handle our new asynchronous
create() function a bit differently. Imagine that our API accepts a
POST request with the same base URL and similar parameters:

create(date: string, name: string,
       location: number, amount: string): Promise<Meal> {
   let body: string = '';

   // code to assemble our parameters into body in whatever format
   // the API demands

   return this.http.post(this.baseUrl, body, { headers: this.headers })
      .toPromise()
      .then(response => response.json().data)
      .catch(this.handleError);
}

We didn't go into specifics of how you'd join the various parameters
passed to create() into a single string for the HTTP body because that
would depend on the particular API. CGI-style APIs just accept
name=value parameters one after the other with carriage returns
between them.

[CGI = Common Gateway Interface. A standardized method of passing
information from browser to web server or vice-versa, usually via
forms. The CGI standard dates back to the earliest days of the web.]

REST APIs more often want the body to be a block of JSON. (There's a
function called JSON.stringify() that can assemble parameters into
JSON easily.)

If we did send a block of JSON, we'd want to warn the HTTP receiver at
the API end that we were sending JSON. We'd do that with the HTTP
headers. Headers use a special format, and by importing Header, we've
added a part of Angular that knows how to form them. We'd want a
component variable:
     headers = new Headers({ 'Content-Type': 'application/json' });
Or, if we were just sending text, perhaps
     headers = new Headers({ 'Content-Type': 'text/html' });

This is a list because we could conceivably be sending multiple
headers affecting various aspects of how the HTTP transaction is
handled.

You would alter the update() and delete() functions in the meal
service to call http.put and http.delete methods in a similar way. PUT
generally acts like POST in the REST universe; DELETE usually, but not
always, takes only a URL like GET.

There's much more to Promise handling and HTTP handling than this; for
example, you can add other methods to Promise returns that filter or
otherwise operate on the results. But you'll need to find out about
those for yourself. Meanwhile, we need to consider what happens in the
components talking to the meal service. They're now getting Promises
instead of hard data.

As an example, consider the getMeals() function in
meal-list.component.ts. It used to look like this:

getMeals(id: number): void {
   if (!id) {
      return null;
   }
   this.meals = this.mealService.getList(id, '', '');
}

Now it needs to look like this (using our current example version of
getList() that only takes two parameters):

getMeals(id: number): void {
   if (!id) {
      return null;
   }
   this.mealService.getList(id, '').then(meals => this.meals = meals);
}

The tricky bit is in the .then method. It says "Once this returns a
result, then, using a temporary variable meals as a name for the
results returned, put whatever's in meals in the component variable
this.meals."

getList() returns a Promise, which is why this function can use the
.then method on it. It could also use the .catch method, which could
be used to further trap potential problems. This isn't a very robust
example; it's just a starting point.

The important point is that getMeals() won't make the rest of the code
wait for the Promise to deliver something. The application page will
display, but it may display with an empty meal list. When the response
finally comes, the meal list will fill in. Other parts of the code
have to behave accordingly, testing to see if the meal list is empty
before trying to do the things they need to do. All other functions
which now get a Promise from an asynchronous service would have to be
altered in a similar way.

Asynchronous transactions are a complex topic, one we can't cover here
in full. Here are some starting points to learn more:

-- Understanding JavaScript Promises:
   https://spring.io/understanding/javascript-promises

-- Mozilla Developer Network promise documentation:
   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise

Those two pages are JavaScript documentation and thus may not be as
useful to you as TypeScript or Angular examples, but they explain the
Promise concept fairly clearly. In the Angular tutorial, we recommend
the following three pages:

-- https://angular.io/docs/ts/latest/tutorial/toh-pt4.html
-- https://angular.io/docs/ts/latest/tutorial/toh-pt6.html
-- https://angular.io/docs/ts/latest/guide/server-communication.html

These pages describe setting up a basic Promise service, more details
about handling HTTP transactions, and the detail page on HTTP
handling, respectively. Note that you'll also have to put up with a
lot of explanation of Observables, which Angular would prefer you
learn.
